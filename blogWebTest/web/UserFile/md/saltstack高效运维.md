# salt介绍
saltstack是由thomas Hatch于2011年创建的一个开源项目，设计初衷是为了实现一个快速的远程执行系统。
# salt强大吗
系统管理员日常会进行大量的重复性操作，例如安装软件，修改配置文件，创建用户，批量执行命令等等。如果主机数量庞大，单靠人工维护实在让人难以忍受。<img src="https://images2018.cnblogs.com/blog/1132884/201808/1132884-20180813091653245-1645701236.png" alt="">
　　早期运维人员会根据自己的生产环境来写特定脚本完成大量重复性工作，这些脚本复杂且难以维护。系统管理员面临的问题主要是1、系统配置管理，2、远程执行命令，因此诞生了很多开源软件，系统维护方面有fabric、puppet、chef、ansible、saltstack等，这些软件擅长维护系统状态或方便的对大量主机进行批量的命令执行。
　　salt灵活性强大，可以进行大规模部署，也能进行小规模的系统部署。salt的设计架构适用于任意数量的服务器，从少量本地网络系统到跨越数个数据中心，拓扑架构都是c/s模型，配置简单。
　　不管是几台、几百台、几千台服务器，都可以使用salt在一个中心节点上进行管控，灵活定位任意服务器子集来运行命令。　
　　Salt是python编写的，支持用户通过python自定义功能模块，也提供了大量的python API接口，用户可以根据需要进行简单快速的扩展。
# saltstack的运行方式

- Local&nbsp; 本地运行，交付管理
- Master/Minion&nbsp; &nbsp;<<<&nbsp; &nbsp;常用方式&nbsp; &nbsp;
- Salt SSH&nbsp; &nbsp;不需要客户端

# salt部署基本架构
在安装salt之前，先理解salt架构中各个角色，主要区分是salt-master和salt-minion，顾名思义master是中心控制系统，minion是被管理的客户端。
salt架构中的一种就是master > minion。
<img src="https://images2018.cnblogs.com/blog/1132884/201808/1132884-20180813093004906-1141972356.png" alt="" width="467" height="175">
在远程执行系统中，salt用python通过函数调用完成任务。
运行salt依赖包
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
python
zeromq
pyzmp
pycrypto
msgpack-python
yaml
jinja2
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
解决依赖包最简单的办法就是用安装包管理器，yum工具
# 服务器环境准备
<table border="0">
<tbody>
<tr>
<td>服务器环境</td>
<td>centos7(master)</td>
<td>centos7(master)</td>
</tr>
<tr>
<td>
ip地址
</td>
<td>192.168.178.131</td>
<td>192.168.178.132</td>
</tr>
<tr>
<td>
身份
</td>
<td>master</td>
<td>slave</td>
</tr>
<tr>
<td>
软件包
</td>
<td>salt-master</td>
<td>salt-minion</td>
</tr>
</tbody>
</table>
### 修改虚拟机ip地址为静态地址，并且确保可上网
```python<img id="code_img_opened_2e0fc437-f05d-495b-be8f-8d1e75003b44" class="code_img_opened" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">

<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
TYPE="Ethernet"
PROXY_METHOD="none"
BROWSER_ONLY="no"
BOOTPROTO="static"
DEFROUTE="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_FAILURE_FATAL="no"
IPV6_ADDR_GEN_MODE="stable-privacy"
NAME="ens33"
UUID="7d4f9ede-810f-4976-a01b-250b845c99cc"
DEVICE="ens33"
ONBOOT="yes"
IPADDR=192.168.11.131
NETMASK=255.255.255.0
GATEWAY=192.168.11.1
DNS1=119.29.29.29
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
```
```python<img id="code_img_opened_b013ca03-99c5-477f-a322-8ab7137cf831" class="code_img_opened" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">

<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
TYPE="Ethernet"
PROXY_METHOD="none"
BROWSER_ONLY="no"
BOOTPROTO="static"
DEFROUTE="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_FAILURE_FATAL="no"
IPV6_ADDR_GEN_MODE="stable-privacy"
NAME="ens33"
UUID="f9fc5929-8594-466e-a041-34caee8c1e32"
DEVICE="ens33"
ONBOOT="yes"
IPADDR=192.168.11.132
NETMASK=255.255.255.0
GATEWAY=192.168.11.1
DNS1=119.29.29.29
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
```
```python<img id="code_img_opened_de2efba5-e308-4a85-b178-ed7cb4ffcf41" class="code_img_opened" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">

# Generated by NetworkManager
nameserver 119.29.29.29
```
```
```python<img id="code_img_opened_3cb55d60-938e-49a9-8f4c-1aaa802bf0e7" class="code_img_opened" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">

127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.11.132  slave
192.168.11.131  master
```
```
&nbsp;
### 关闭服务器安全策略
```python<img id="code_img_opened_6a30d900-5037-4523-94ee-4fc03cf92f05" class="code_img_opened" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">

<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
关闭firewalld
systemctl disable firewalld
systemctl stop firewalld

关闭iptables
iptables -F

关闭selinux
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
```
### 安装saltstack
&nbsp;salt软件包需要epel源的支持，那么下载
EPEL的全称叫 Extra Packages for Enterprise Linux&nbsp;。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。装上了 EPEL之后，就相当于添加了一个第三方源。
```python
```
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
```
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo<br>yum clean all #清空缓存<br>yum makecache #生成yum缓存
```
&nbsp;安装好epel源就可以开始安装salt了
```python
查看salt包<br>yum list salt<br><br>安装salt-master
yum install salt-master -y
```
```python
安装salt-minion
yum install salt-minion -y
```
### salt端口
安装好salt之后开始配置，salt-master默认监听两个端口：
```python
4505   publish_port 提供远程命令发送功能
4506   ret_port     提供认证，文件服务，结果收集等功能
确保客户端可以通信服务器的此2个端口，保证防火墙允许端口通过。因此在测试环境直接关闭防火墙。
```
### 配置文件
```python
salt-master的配置文件是/etc/salt/master
salt-minion的配置文件是/etc/salt/minion
配置文件中包含了大量可调整的参数，这些参数控制master和minion各个方面
```
配置salt-master
```python<img id="code_img_opened_f074b724-42de-4908-a7a0-930f6a1a918d" class="code_img_opened" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">

<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
# salt运行的用户，影响到salt的执行权限
user: root

#s alt的运行线程，开的线程越多一般处理的速度越快，但一般不要超过CPU的个数
worker_threads: 10

# master的管理端口
publish_port : 4505

# master跟minion的通讯端口，用于文件服务，认证，接受返回结果等
ret_port : 4506

# 如果这个master运行的salt-syndic连接到了一个更高层级的master,那么这个参数需要配置成连接到的这个高层级master的监听端口
syndic_master_port : 4506

# 指定pid文件位置
pidfile: /var/run/salt-master.pid
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
```
超哥的salt-master文件
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master ~]# grep -v ^# /etc/salt/master|grep -v ^$
interface: 0.0.0.0  #绑定到本地的0.0.0.0地址
publish_port: 4505　　#管理端口，命令发送
user: root　　　　　　#运行salt进程的用户
worker_threads: 5　　#salt运行线程数，线程越多处理速度越快，不要超过cpu个数
ret_port: 4506　　#执行结果返回端口
pidfile: /var/run/salt-master.pid #pid文件位置
log_file: /var/log/salt/master　　#日志文件地址<br><br>#自动接收minion的key<br>auto_accept: False
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
```python<img id="code_img_opened_41436335-cdfe-4c2b-bf85-d9bf8e8cb5d6" class="code_img_opened" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="">

<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
# minion的识别ID，可以是IP，域名，或是可以通过DNS解析的字符串
id: slave
 
# salt运行的用户权限
user: root
 
# master的识别ID，可以是IP，域名，或是可以通过DNS解析的字符串
master : master
 
# master通信端口
master_port: 4506
 
# 备份模式，minion是本地备份，当进行文件管理时的文件备份模式
backup_mode: minion
 
# 执行salt-call时候的输出方式
output: nested
 
# minion等待master接受认证的时间
acceptance_wait_time: 10
 
# 失败重连次数，0表示无限次，非零会不断尝试到设置值后停止尝试
acceptance_wait_time_max: 0
 
# 重新认证延迟时间，可以避免因为master的key改变导致minion需要重新认证的syn风暴
random_reauth_delay: 60
 
# 日志文件位置
log_file: /var/logs/salt_minion.log
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
```
超哥的satl-minion文件
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@slave ~]# grep -v ^# /etc/salt/minion|grep -v ^$
master: master
master_port: 4506
user: root
id: slave
acceptance_wait_time: 10
log_file: /var/log/salt/minion
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
### &nbsp;启动salt-master和salt-minion
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
systemctl start salt-minion
systemctl start salt-master<br><br>#检查salt状态<br>systemctl status salt-minion<br>systemctl status salt-master
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
### 在master上接收minion秘钥
在minion启动后连接master会请求master为其签发证书，等待证书签发完成后，master可以信任minion，并且minion和master之间的通信是加密的。
在salt-master执行
salt-key命令用于管理mionion秘钥
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master ~]# salt-key -L
Accepted Keys:
Denied Keys:
Unaccepted Keys:
slave　　　　#此时已经出现slave
Rejected Keys:
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
此时slave已经出现在unaccepted keys中，说明minion已经和master联系，并且master已经获取了minion的公钥，等待下一步指令。
### 检查master和minion的秘钥匹配
在master上执行
```python
[root@master ~]# salt-key -f slave
Unaccepted Keys:
slave:  0a:b9:97:b5:9a:65:b8:49:a1:50:a5:6a:66:ce:33:ea
```
然后可以在minion上获取minion的秘钥
```python
[root@slave ~]# salt-call --local key.finger
local:
    0a:b9:97:b5:9a:65:b8:49:a1:50:a5:6a:66:ce:33:ea
```
因此可确认秘钥匹配，在master上接收秘钥
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master ~]# salt-key -a slave
The following keys are going to be accepted:
Unaccepted Keys:
slave
Proceed? [n/Y] y
Key for minion slave accepted.
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
确认接收秘钥后，检验minion秘钥是否被接收
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master ~]# salt-key -L
Accepted Keys:
slave
Denied Keys:
Unaccepted Keys:
Rejected Keys:
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
秘钥接收完成后，就可以执行第一条salt啦<img src="https://images2018.cnblogs.com/blog/1132884/201808/1132884-20180813114327824-401165658.png" alt="">
# salt-key
只有`Master`接受了`Minion Key`后，才能进行管理。具体的认证命令为`salt-key`常用的有如下命令。
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@linux-node1 ~]# salt-key -L
Accepted Keys：  #已经接受的key
Denied Keys：    #拒绝的key
Unaccepted Keys：#未加入的key
Rejected Keys：#吊销的key

#常用参数
-L  #查看KEY状态
-A  #允许所有
-D  #删除所有
-a  #认证指定的key
-d  #删除指定的key
-r  #注销掉指定key（该状态为未被认证）

**#在master端****/etc/salt/master配置
auto_accept: True   #如果对Minion信任,可以配置master自动接受请求**
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
# salt-key的使用
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
#列出当前所有的key
[root@salt0-master ~]# salt-key 
Accepted Keys:
salt1-minion.example.com
salt2-minion.example.com
salt3-minion.example.com
salt4-minion.example.com
Denied Keys:
Unaccepted Keys:
Rejected Keys:

#添加指定minion的key
[root@salt0-master ~]# salt-key  -a salt1-minion.example.com -y
#添加所有minion的key
[root@salt0-master ~]# salt-key  -A  -y

#删除指定的key
[root@salt0-master ~]# salt-key -d salt1-minion.example.com -y
#删除所有的key
[root@salt0-master ~]# salt-key -D -y
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
&nbsp;
&nbsp;
&nbsp;
# 日常命令参数
首先知道master和minion都安装了什么文件，然后才知道怎么操作
**master端**
```python
rpm -ql salt-master
```
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
/etc/salt/master      # salt master主配置文件
/usr/bin/salt           #salt master 核心操作命令
/usr/bin/salt-cp       #salt 文件传输命令
/usr/bin/salt-key    #salt证书管理
/usr/bin/salt-master    #salt master 服务命令
/usr/bin/salt-run          #salt master runner命令
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
**slave端**
```python
[root@slave  ~]$rpm -ql salt-minion
```
```python
/etc/salt/minion     #minion配置文件
/usr/bin/salt-call    #拉取命令
/usr/bin/salt-minion   #minion服务命令
/usr/lib/systemd/system/salt-minion.service   #minion启动脚本
```
# 第一条salt命令
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master ~]# salt '*' test.ping
slave:
    True<br><br># salt 是一个命令 <br># * 表示目标主机, 在这里代表所有目标主机 <br># test.ping是salt远程执行的一个模块下面的方法。<br>
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
这是条很简单的探测minion主机存活命令，也是远程执行命令，我们通过master发送消息给"*"所有的minion，并且告诉他们运行salt内置的命令（也是python模块中的一个函数），返回true表示slave机器监控存活。
&nbsp;
test模块实际上还有许多其他的函数
```python<img id="code_img_closed_1c039981-ee0f-45d6-b8ea-402a18340663" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="">test其他函数```
测试下test.echo
```python
[root@master 192.168.199.155 ~]$salt '*' test.echo 'chaoge nb666'
slave:
    chaoge nb666
```
test.fib生成斐波那契数列
菲波那切数列定义是第0项是0，第1项是1，数列从第3项开始，每一项等于前两项之和。
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.199.155 ~]$salt '*' test.fib 50
slave:
    |_
      - 0
      - 1
      - 1
      - 2
      - 3
      - 5
      - 8
      - 13
      - 21
      - 34
    - 1.09672546387e-05
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
### 小结
此前在机器上安装了salt minion和salt master，进行了最简单的连接，然后master接受了minion的秘钥，运行了第一条test.ping命令
# salt命令组成结构
**在命令行输入的命令都是 　　　　执行模块**
**等到命令写入到文件中，&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;就叫做状态模块**
```python
salt --help #即可查看salt帮助
[root@master 192.168.199.155 ~]$salt --help<br>Usage: salt [options] '<target>' <function> [arguments]
salt命令 参数 目标 salt模块的函数 远程执行的参数


```
**完整的五部分命令**
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
#--summary参数显示salt命令的概要<br>[root@master 192.168.199.155 ~]$salt --summary '*' cmd.run 'hostname'
slave:
    slave


-------------------------------------------
Summary
-------------------------------------------
# of Minions Targeted: 1
# of Minions Returned: 1
# of Minions Did Not Return: 0
-------------------------------------------
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
**列出所有salt的sys模块**
```python
#与系统交互的sys模块<br>[root@master 192.168.11.72 ~]$salt 'slave' sys.list_modules
```
**远程执行命令模块**
**cmd是超级模块，所有shell命令都能执行**
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.11.72 ~]$salt 'slave' cmd.run 'ps -ef|grep python'
slave:
    root        905      1  0 07:31 ?        00:00:02 /usr/bin/python -Es /usr/sbin/tuned -l -P
    root       3843      1  0 11:05 ?        00:00:00 /usr/bin/python /usr/bin/salt-minion
    root       3846   3843  0 11:05 ?        00:00:01 /usr/bin/python /usr/bin/salt-minion
    root       4031      1  0 11:31 ?        00:00:00 /usr/bin/python /usr/bin/salt-minion
    root       4032   4031  0 11:31 ?        00:00:00 /bin/sh -c ps -ef|grep python
    root       4034   4032  0 11:31 ?        00:00:00 grep python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
&nbsp;
&nbsp;
**远程安装nginx**
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
#在minion上安装nginx
[root@master 192.168.11.72 ~]$salt 'slave' pkg.install "nginx"
#卸载minion上的nginx
[root@master 192.168.11.72 ~]$salt 'slave' pkg.remove "nginx"
#检查pkg包的版本
[root@master 192.168.11.72 ~]$salt 'slave' pkg.version "nginx"
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
**远程管理服务模块**
管理服务是系统管理员的重要任务，通过salt管理minion服务会很简单，使用service模块
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.11.72 ~]$salt 'slave' service.start "nginx"
slave:
    True
[root@master 192.168.11.72 ~]$salt 'slave' service.status "nginx"
slave:
    True
[root@master 192.168.11.72 ~]$salt 'slave' service.stop "nginx"
slave:
    True
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
### &nbsp;
### 与标准的Linux命令一样，salt的命令一样用法
--out控制salt命令结果输出的格式
JSON
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.199.155 ~]$salt --out=json '*' cmd.run_all 'hostname'
{
    "slave": {
        "pid": 2268,
        "retcode": 0,
        "stderr": "",
        "stdout": "slave"
    }
}
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
YAML
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.199.155 ~]$salt --out=yaml '*' cmd.run_all 'hostname'
slave:
  pid: 2289
  retcode: 0
  stderr: ''
  stdout: slave
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
## YAML讲解
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
在学习saltstack过程中，第一要点就是States编写技巧，简称SLS文件。这个文件遵循YAML语法。初学者看这玩意很容易懵逼，来，超哥拯救你学习YAML语法
json xml yaml 数据序列化格式
yaml容易被解析，应用于配置文件

salt的配置文件是yaml配置文件，不能用tab
saltstack,k8s,ansible都用的yaml格式配置文件


语法规则
    大小写敏感
    使用缩进表示层级关系   
    缩进时禁止tab键，只能空格
    缩进的空格数不重要，相同层级的元素左侧对其即可
    # 表示注释行
yaml支持的数据结构
    对象： 键值对，也称作映射 mapping 哈希hashes 字典 dict    冒号表示 key: value   key冒号后必须有
    数组： 一组按次序排列的值，又称为序列sequence 列表list     短横线  - list1
    纯量： 单个不可再分的值

对象：键值对
yaml
    first_key:
      second_key:second_value

python
    {
        'first_key':{
            'second_key':'second_value',
        }
    }
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
&nbsp;
```python
YAML是YAML Ain't Markup Language的首字母缩写，YAML的语法简单，<br>结构体通过空格展示<br>项目使用 '-' 代表<br>键值对通过 ':' 分割
```
```python
YAML语法遵循固定的缩进风格，表示数据层级结构关系，saltstack需要每个缩进级别由2个空格组成，禁止用tabs！！！
```
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
Python中的字典是简单的键值对，go语言中称作哈希表map<br>字典的key通过冒号分割<br><br>key在YAML中表现形式是一个冒号结果的字符串<br>my_key: my_value<br>转化到python语法中，上述命令为<br>{'my_key':'my_value'}<br><br>value还可以通过缩进和key关联，四个空格！！<br>my_key:<br>    my_value <br>转化为python语法同样的<br>{'my_key':'my_value'}<br><br>YAML语法中字典是可以嵌套的<br>one_dict_key:<br>    two_dict_key:value_dict<br>转化为python语法
{<br>　　'one_dict_key':{<br>　　　　'two_dict_key':'value_dict'<br>　　}<br>}
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```


```
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
短横杠
YAML语法表示列表，使用一个横杠加一个空格
多个项使用同样的缩进级别作为同一个列表的部分
- list_value_one
- list_value_two
- list_value_three<br>列表可以作为一个键值对的value，例如一次性要安装多个软件<br>my_dict:<br>  - l1<br>  - l2<br>  - l3<br>转化为python代码理解就是
{<br>　　'my_dict':['l1','l2',;l3]<br>}
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```


```
# &nbsp;目标定位字符串
　　之前的salt命令我们都是使用 salt '*'控制所有minion，并且我们只有一个“slave”，但是生产环境的服务器很可能是成千上百的minion，因此需要灵活地定位所需的服务器并且执行远程命令。
<img src="https://img2018.cnblogs.com/blog/1132884/201811/1132884-20181117232326998-1247744356.png" alt="">
&nbsp;
```python
1.全局匹配
[root@master 192.168.11.72 ~]$salt '*' test.ping
slave:
    True
```
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
Linux通配符
*               代表任意字符，或空字符串
?               代表一个字符，不可以为空
[a-z] [0-9]     代表任何一个小写字母

[root@master 192.168.11.72 ~]$salt 'slav?' test.ping
slave:
    True

[root@master 192.168.11.72 ~]$salt '[a-z]lave' test.ping
slave:
    True            <br>salt海支持python的re正则表达式
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
# state模块定义主机状态
之前执行的远程命令，都是一个过程式的，类似一段shell或者python脚本执行，执行一次触发一次相同的功能。
那么大量的minion上运行远程命令就必须使用salt提供的“状态管理”了，状态是对minion的一种描述和定义，运维不需要关心部署是如何完成的，只需要描述minion需要达到什么状态。
接下来通过state模块部署nginx
master端
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
vim /etc/salt/master <br>#打开注释，写入以下，必须严格遵循语法，空格
file_roots:
  base:
    - /srv/salt/base
 dev:
   - /srv/salt/dev
 test:
   - /srv/salt/test
 prod:
   - / srv/salt/prod<br><br>
#此步骤在master和minion都需要执行，都需要文件夹，和nginx.sls文件<br>[root@master&nbsp; ~]$mkdir -p /srv/salt/{base,dev,test,prod}
[root@slave&nbsp; &nbsp;~]$mkdir -p /srv/salt/{base,dev,test,prod}
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```


```
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
#这个nginx.sls状态文件，在master和minion上都得有<br>[root@master /srv/salt/base]$cat nginx.sls
nginx-install:
  pkg.installed:
    - name: nginx

nginx-service:
  service.running:
    - name: nginx
    - enable: True
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
```python
解释下nginx.sls描述文件<br>sls配置文件都遵循YAML语言描述
第一条命令使用了pkg.install安装命令，相对于运行了yum install，而此时state模块会判断nginx是否安装了，如果没有安装就进行安装，安装了就什么都不做。
状态描述都会遵循这个原则，只有检测到真实状态和所需状态不一就会执行此功能，这种性质叫做幂等性。
```
此时用state模块部署nginx软件，通过我们编写的nginx.sls描述性配置文件，命令行调用state模块的sls函数。
```python
#启动命令，此时slave已经安装且存活了nginx，进行状态管理
[root@master  /srv/salt/base]$salt 'slave' state.sls nginx
```
可以去slave测试关闭nginx，删除nginx，重新执行命令，一样可以安装启动nginx
通过master检查slave的nginx状态
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.199.155 /srv/salt/base]$salt 'slave' cmd.run 'ps -ef|grep nginx'
slave:
    root       8543      1  0 Sep14 ?        00:00:00 nginx: master process /usr/sbin/nginx
    nginx      8544   8543  0 Sep14 ?        00:00:00 nginx: worker process
    root       8592   8591  0 00:03 ?        00:00:00 /bin/sh -c ps -ef|grep nginx
    root       8594   8592  0 00:03 ?        00:00:00 /bin/sh -c ps -ef|grep nginx
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
# Salt采集静态信息之Grains
如果你入职了，你的老板让你收集公司300台服务器的相关硬件信息，你是一台台登录呢？还是选择用salt收集呢？又或者用python的salt-api写脚本呢
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
Grains 是saltstack组件中非常重要之一，在配置部署时候回经常使用，Grains记录minion的静态信息，比如常用属性，CPU、内存、磁盘、网络信息等。
**Minions的Grains信息是Minion启动时采集汇报给Master的**<br>Grains是以 key  value形式存储的数据库，可以看做Host的元数据（metadata）<br>Grains保存着收集到的客户端的详细信息<br>**如果slave机器数据变化，grains就过期了**
在生产环境中需要自定义Grains，可以通过
Minion配置文件
Grains相关模块定义
Python脚本定义<br><br>salt 'slave' sys.doc grains#查看grains的命令用法
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
Grains
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
Grains人为是描述minion本身固有的静态属性数据，列出主机所有Grains数据<br><br>
[root@master 192.168.11.72 ~]$salt 'slave' grains.items<br>slave:<br>----------<br>SSDs:<br>biosreleasedate:<br>05/19/2017<br>biosversion:<br>6.00　　
信息过长，已经省略
salt 'slave' grains.ls&nbsp; #列出所有grains方法
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```


```
检索某些数据
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.11.72 ~]$salt 'slave' grains.item os id host
slave:
    ----------
    host:
        slave
    id:
        slave
    os:
        CentOS
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
利用Grains静态信息定位主机
超哥以前公司有100+的redhat操作系统，80+的centos，在不知道salt之前很是懵逼。。
除了系统的不同，还有不同的系统版本，redhat6.x centos6.x..
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
两种写法：<br>salt '*' grains.item key1 key2 key3<br>salt '*' -G<br><br>#定位Cenots的机器<br>[root@master 192.168.11.72 ~]$salt -G 'os:CentOS' test.ping
slave:
    True<br>#定位操作系统系统是7系列的机器
[root@master 192.168.11.72 ~]$salt -G 'osrelease:7*' test.ping<br>slave:<br>True
#找出ip地址
salt '*' grains.item fqdn_ip4
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```


```
因此用grains.items列出所有的数据匹配主机，以及根据单一信息定位数据，Grains还可以自定义来满足不同的需求。
### 自定义设置Grains数据
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
#设置数据<br>[root@master 192.168.11.72 ~]$salt 'slave' grains.setval cpu_num 8
slave:
    ----------
    cpu_num:
        8<br>#查询数据<br>
[root@master 192.168.11.72 ~]$salt 'slave' grains.item cpu_num
slave:
    ----------
    cpu_num:
        8
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
在master端设置Grains静态数据，原理会将此数据添加到minion服务器的配置文件的/etc/salt/grains
```python
[root@slave 192.168.11.71 ~]$cat /etc/salt/grains
cpu_num: 8
```
对于复杂的数据结构，可以添加灵活的JSON语法
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.11.72 ~]$salt 'slave' grains.setval cpu_info '["Intel","Xeon","10"]'
slave:
    ----------
    cpu_info:
        - Intel
        - Xeon
        - 10
[root@master 192.168.11.72 ~]$salt 'slave' grains.item cpu_info
slave:
    ----------
    cpu_info:
        - Intel
        - Xeon
        - 10
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
此时可以检查minion服务器上的grains文件
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@slave 192.168.11.71 ~]$cat /etc/salt/grains
cpu_info:
- Intel
- Xeon
- '10'
cpu_num: 8
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
**因此Grains数据写入配置文件后，重启salt-minion服务，数据也不会丢失**
想要删除可以通过grains.delval命令删除，或者去minion的配置文件删除配置一样完成操作（或者删除文件）
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
1.方法一，清空值
[root@master 192.168.11.72 ~]$salt 'slave' grains.delval cpu_info
slave:
    None
[root@master 192.168.11.72 ~]$salt 'slave' grains.delval cpu_num
slave:
    None<br><br>2.方法二 删除minion的grains配置文件，重启服务
[root@slave 192.168.11.71 ~]$rm -rf /etc/salt/grains<br>[root@slave 192.168.11.71 ~]$!sys<br>systemctl restart salt-minion
检查结果删除成功
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
# &nbsp;数据管理中心之Pillar组件
Pillar也是saltstack组件中非常重要的组件之一，称作数据管理中心，经常配合states在大规模的配置管理中使用。
Pillar是动态的，存储在master端，提供和给minion端
Pillar在SaltStack中主要的作用是存储和定义配置管理中需要的一些数据，比如软件版本号，用户账号密码等，保证敏感数据不被其他minion看到
存储格式与Grains类似，都是YAML格式
<img src="https://img2018.cnblogs.com/blog/1132884/201811/1132884-20181117231503359-705573661.png" alt="">
在master配置文件中有一段Pillar settings选项专门定义Pillar的参数
&nbsp;
```python
cat /etc/salt/master  <br>#此配置代表pillar的工作根目录，在/srv/pillar下，然后可以新建sls文件
#pillar_roots:
#  base:
#    - /srv/pillar
```
默认pillar的工作目录在/srv/pillar目录下，执行如下代码
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
mkdir -p /srv/pillar
#指定环境，标记，引用packages.sls和services.sls
vim /srv/pillar/top.sls
base:
  '*':
      - packages
      - services<br>
vim /srv/pillar/packages.sls
nginx:
    packages-name: nginx
    version: 1.12.2

vim /srv/pillar/packages.sls
nginx:
    port: 80
    user: root<br><br>
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
检查我们设置的pillar值
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master 192.168.199.155 /srv/pillar]$salt '*' pillar.item nginx
slave:
    ----------
    nginx:
        ----------
        packages-name:
            nginx
        port:
            80
        user:
            root
        version:
            1.12.2
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
# Pillar与Grains对比
```python
pillar与Grains对比

类型     数据采集方式   应用场景                   定义位置
Grains   静态         minion启动时收集  数据查询  目标选择  配置管理   minion
Pillar   动态         master进行自定义  目标选择  配置管理  敏感数据   master
```
# Python API调用SaltStack
SaltStack本身提供salt(usr/bin/salt)来交互管理，但是去服务器上敲命令肯定不是一个长远之计，这时候python就体现了nb的功能。
Python API就是给Python提供的API使用，需要在SaltStack master上运行
实例代码
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
[root@master  ~]$python
Python 2.7.5 (default, Jul 13 2018, 13:06:57)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import salt.client
>>> local = salt.client.LocalClient()  #<salt.client.LocalClient object at 0x7f886dbdd850>
>>> local.cmd('*','cmd.run',['hostname'])#向所有minion发送命令
{'slave': 'slave'}
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
因此python API就是提供了向saltstack发送命令的入口。
### 通过API获取saltstack的配置文件
获取master配置文件
```python
>>> import salt.config #导入salt配置模块
>>> m_opts=salt.config.client_config('/etc/salt/master') #读取salt配置文件，得到一个字典数据
```
获取minion配置文件
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
Python 2.7.5 (default, Jul 13 2018, 13:06:57)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import salt.client
>>> salt.config.minion_config('/etc/salt/minion') #读取minion配置文件，得到字典数据，通过字典方法可以查看信息
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
## Python API介绍
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
/usr/bin/salt默认使用的接口是LocalClient，该接口只能在salt master上使用
[root@master  ~]$python
Python 2.7.5 (default, Jul 13 2018, 13:06:57)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import salt.client
>>> local = salt.client.LocalClient()  #<salt.client.LocalClient object at 0x7f886dbdd850>
>>> local.cmd('*','cmd.run',['hostname'])#向所有minion发送命令
{'slave': 'slave'}
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
逐条返回结果，local.cmd_iter()
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
>>> ret=local.cmd_iter('*','test.ping')
>>> ret
<generator object cmd_iter at 0x7f886d455c80>
>>> for i in ret:
...     print i
...
{'slave': {'retcode': 0, 'ret': True}}
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
```
菲波那切数列
```python
>>> local.cmd('*','test.fib',[10])
{'slave': [[0, 1, 1, 2, 3, 5, 8], 2.1457672119140625e-06]}
```
检查minion服务器信息
```python
>>> local.cmd('*','cmd.run',['hostname'])
{'slave': 'slave'}
>>> local.cmd('*','cmd.run',['ifconfig'])
>>> local.cmd('*','cmd.run',['crontab -l'])
>>> local.cmd('*','cmd.run',['df -h'])
```
启停minion的服务，如nginx
```python
<a title="复制代码"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>```
>>> local.cmd('*','service.stop',['nginx'])
{'slave': True}
>>> local.cmd('*','service.status',['nginx'])
{'slave': False}
>>> local.cmd('*','service.start',['nginx'])
{'slave': True}
```